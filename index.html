<!DOCTYPE html>
<html>
	<head>
		<title>FontTool</title>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="styles.css">
		<script>
			// 标签页切换函数
			function switchTab(tabName) {
				console.log('开始切换标签页:', tabName);
				
				// 隐藏所有标签页内容
				const convertTab = document.getElementById('convert-tab');
				const splitTab = document.getElementById('split-tab');
				
				console.log('convert-tab:', convertTab);
				console.log('split-tab:', splitTab);
				
				// 移除所有标签的active类
				const tabs = document.querySelectorAll('.tab');
				tabs.forEach(tab => {
					tab.classList.remove('active');
				});
				
				// 根据tabName切换
				if (tabName === 'convert') {
					if (convertTab) convertTab.classList.add('active');
					if (splitTab) splitTab.classList.remove('active');
					// 为对应的按钮添加active类
					const convertBtn = document.querySelector('[onclick="switchTab(\'convert\')"]');
					if (convertBtn) convertBtn.classList.add('active');
					console.log('切换到格式转换');
				} else if (tabName === 'split') {
					if (convertTab) convertTab.classList.remove('active');
					if (splitTab) splitTab.classList.add('active');
					// 为对应的按钮添加active类
					const splitBtn = document.querySelector('[onclick="switchTab(\'split\')"]');
					if (splitBtn) splitBtn.classList.add('active');
					console.log('切换到字体拆分');
				}
				
				console.log('标签页切换完成');
			}
			
			// 处理拆分文件选择
			function handleSplitFileSelect(event) {
				console.log('文件选择被触发:', event);
				const file = event.target.files[0];
				console.log('选择的文件:', file);
				if (file) {
					// 存储文件对象，用于后续处理
					window.splitFileData = file;
					window.splitInputFile = file.name; // 存储文件名
					document.getElementById('split-input-file').value = file.name;
					
					console.log('文件信息已更新:', file.name);
					
					// 显示文件信息
					const infoEl = document.getElementById('split-file-info');
					infoEl.innerHTML = `
						<div class="font-info">
							<strong>${file.name}</strong><br>
							文件大小: ${(file.size / 1024).toFixed(1)} KB
						</div>
					`;
					infoEl.style.display = 'block';
					console.log('文件信息已显示');
				} else {
					console.log('没有选择文件');
				}
			}
			
			// 选择语言
			function selectLanguage(lang) {
				window.selectedLanguage = lang;
				document.querySelectorAll('.language-option').forEach(option => {
					option.classList.remove('selected');
				});
				document.querySelector(`[data-lang="${lang}"]`).classList.add('selected');
			}
			
			// 文件转base64函数
			function fileToBase64(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.readAsDataURL(file);
					reader.onload = () => resolve(reader.result);
					reader.onerror = error => reject(error);
				});
			}
			
			// 开始拆分处理
			function startSplitProcess() {
				console.log('开始拆分字体...');
				console.log('当前全局变量状态:', {
					splitFileData: window.splitFileData,
					splitInputFile: window.splitInputFile,
					selectedLanguage: window.selectedLanguage
				});
				
				const fontFamily = document.getElementById('font-family').value.trim();
				const numChunks = parseInt(document.getElementById('num-chunks').value);

				console.log('参数检查:', {
					splitInputFile: window.splitInputFile,
					fontFamily,
					selectedLanguage: window.selectedLanguage,
					numChunks
				});

				if (!window.splitInputFile) {
					alert('请先选择字体文件');
					return;
				}

				if (!fontFamily) {
					alert('请输入字体名称');
					return;
				}

				if (!window.selectedLanguage) {
					alert('请选择语言类型');
					return;
				}

				// 禁用按钮
				document.getElementById('split-button').disabled = true;
				alert('开始拆分字体...');

				// 调用Python API
				if (window.splitFileData) {
					// 使用文件数据
					fileToBase64(window.splitFileData).then(fileData => {
						return pywebview.api.split_font_and_generate_css_with_file(
							fileData,
							window.splitFileData.name,
							fontFamily,
							window.selectedLanguage,
							numChunks,
							window.splitOutputFolder || null
						);
					}).then(result => {
						console.log('拆分完成，返回结果:', result);
						document.getElementById('split-button').disabled = false;
						
						if (result && result.success) {
							alert(`拆分完成！生成了 ${result.subset_count} 个子集文件`);
						} else {
							alert('拆分失败: ' + (result.message || '未知错误'));
						}
					}).catch(error => {
						console.error('拆分过程中出错:', error);
						document.getElementById('split-button').disabled = false;
						alert('拆分过程中出错: ' + error.message);
					});
				} else {
					alert('文件数据丢失，请重新选择文件');
					document.getElementById('split-button').disabled = false;
				}
			}
		</script>
	</head>

	<body>
		<div class="container">
			<!-- 状态显示区域 -->
			<div id="status-bar" class="status-bar" style="display: none;">
				<div class="status-content">
					<span id="status-icon">⏳</span>
					<span id="status-text">处理中...</span>
					<button id="cancel-btn" class="cancel-btn" onclick="cancelProcessing()" style="display: none;">取消</button>
				</div>
				<div id="progress-bar" class="progress-bar">
					<div id="progress-fill" class="progress-fill"></div>
				</div>
			</div>
			
			<div class="tabs">
				<button class="tab active" onclick="switchTab('convert')">格式转换</button>
				<button class="tab" onclick="switchTab('split')">字体拆分</button>
			</div>

			<!-- 字体拆分标签页 -->
			<div id="split-tab" class="tab-content">
				<h2>这里可以拆分字体并上传到CDN 你将得到一个css文件📃</h2>
				
				<div class="form-group">
					<label for="split-input-file">选择字体文件 (.ttf, .otf, .woff, .woff2)</label>
					<div class="input-group drop-zone" id="split-drop-zone" ondrop="handleDrop(event, 'split-input-file')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
						<input type="text" id="split-input-file" placeholder="请选择字体文件或拖拽文件到此处" readonly>
						<input type="file" id="splitFileInput" accept=".ttf,.otf,.woff,.woff2" style="display: none;" onchange="handleSplitFileSelect(event)">
						<button class="button secondary" onclick="console.log('点击选择文件按钮'); document.getElementById('splitFileInput').click();">选择文件</button>
					</div>
					<div id="split-file-info" class="file-info" style="display: none;"></div>
				</div>

				<div class="form-group">
					<label for="font-family">字体名称 (font-family)</label>
					<input type="text" id="font-family" placeholder="请输入字体名称，例如: MyFont">
				</div>       

				<div class="form-group">
					<label>选择语言类型</label>
					<div class="language-options">
						<div class="language-option" data-lang="zh" onclick="selectLanguage('zh')">
							<strong>简体中文</strong>
						</div>
						<div class="language-option" data-lang="tc" onclick="selectLanguage('tc')">
							<strong>繁体中文</strong>
						</div>
						<div class="language-option" data-lang="ja" onclick="selectLanguage('ja')">
							<strong>日文</strong>
						</div>
					</div>
				</div>

				<div class="form-group">
					<label for="num-chunks">拆分数量</label>
					<input type="number" id="num-chunks" value="200" min="1" max="1000" placeholder="建议值：200-500">
				</div>

				<div class="form-group">
					<label for="split-output-folder">输出文件夹（可选）</label>
					<div class="input-group">
						<input type="text" id="split-output-folder" placeholder="留空则使用字体文件所在目录" readonly>
						<button class="button secondary" onclick="selectSplitOutputFolder()">选择文件夹</button>
					</div>
				</div>

				<button class="button" onclick="startSplitProcess()" id="split-button">开始拆分和上传</button>

				<!-- 简化的任务状态显示 -->
				<div id="task-status" class="task-status" style="display: none;">
					<div class="task-status-content">
						<div class="task-status-icon" id="task-status-icon">⏳</div>
						<div class="task-status-text">
							<div class="task-status-title" id="task-status-title">准备中...</div>
							<div class="task-status-detail" id="task-status-detail">请稍候</div>
						</div>
					</div>
					<div id="task-progress" class="progress" style="display: none;">
						<div class="progress-bar" id="task-progress-bar"></div>
					</div>
				</div>
				
				<div id="split-results" class="result-list" style="display: none;"></div>
			</div>

			<!-- 格式转换标签页 -->
			<div id="convert-tab" class="tab-content active">
				<h2>字体格式转换</h2>
				
				<!-- 文件选择区域 -->
				<div class="main-drop-zone" id="mainDropZone" ondrop="handleDrop(event, 'convert-input')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
					<div class="drop-zone-content">
						<div class="drop-icon">📁</div>
						<h3>拖拽字体文件到此处</h3>
						<p>支持 TTF、OTF、WOFF、WOFF2 格式</p>
					</div>
					<div id="convert-file-info" class="file-info" style="display: none;"></div>
				</div>

				<!-- 文件选择区域 -->
				<div class="file-selection-area">
					<input type="file" id="fileInput" accept=".ttf,.otf,.woff,.woff2" style="display: none;" onchange="handleFileSelect(event)">
					<button class="select-file-btn" id="selectFileBtn" onclick="document.getElementById('fileInput').click()">选择文件</button>
				</div>

				<!-- 配置选项区域 -->
				<div class="config-section">
					<div class="config-grid two-column">
						<!-- 输出位置 -->
						<div class="config-item">
							<label>输出位置</label>
							<div class="output-folder-section">
								<input type="text" id="outputFolderPath" placeholder="自动检测原文件目录..." readonly>
								<button type="button" id="selectOutputBtn" onclick="selectOutputFolder()">选择目录</button>
							</div>
						</div>
						
						<!-- 输出格式 -->
						<div class="config-item">
							<label>输出格式</label>
							<div class="format-options">
								<label class="format-option">
									<input type="checkbox" id="format-woff2" name="format" value="woff2" checked />
									<span>WOFF2</span>
								</label>
								<label class="format-option">
									<input type="checkbox" id="format-woff" name="format" value="woff" />
									<span>WOFF</span>
								</label>
							</div>
						</div>

						<!-- 字符子集 -->
						<div class="config-item full-width">
							<label>字符子集（可选）</label>
							<p class="help-text">这能大大减小字体文件体积</p>
							<div id="quickCharsContainer" class="checkbox-group"></div>
							<textarea
								id="subsetChars"
								rows="2"
								placeholder="输入或粘贴自定义文本，我们会将你输入的字符与快捷选项进行合并..."
							></textarea>
						</div>

						<!-- 字重选择 -->
						<div class="config-item full-width" id="weightCard" style="display: none">
							<label>字重选择（可变字体）</label>
							<p class="help-text">该字体为可变字体，请选择需要导出的字重版本</p>
							<div id="weightOptions" class="weight-options"></div>
						</div>
					</div>
				</div>


				<!-- 转换按钮区域 -->
				<div class="convert-section">
					<button id="convertBtn" class="convert-btn" onclick="startConversion()" disabled>
						<span class="btn-icon">🚀</span>
						<span class="btn-text">开始转换</span>
					</button>
					<div id="result" class="result info">请先选择字体文件</div>
				</div>
			</div>
		</div>

		<script>
			let inputFile = null
			let outputFolder = null
			let availableWeights = []
			let selectedFileData = null // 存储文件对象
			
			// 字体拆分相关变量
			let splitInputFile = ''
			window.splitOutputFolder = ''
			let selectedLanguage = 'zh'
			
			// 文件转base64函数
			// 选择输出目录
			async function selectOutputFolder() {
				try {
					if (window.pywebview && window.pywebview.api) {
						const folder = await window.pywebview.api.select_output_folder();
						if (folder) {
							document.getElementById('outputFolderPath').value = folder;
							outputFolder = folder;
						}
					} else {
						updateResult("❌ API不可用，请检查应用状态", "error");
					}
				} catch (error) {
					updateResult(`❌ 选择目录失败: ${error.message}`, "error");
				}
			}
			
			// 文件选择处理函数
			function handleFileSelect(event) {
				const file = event.target.files[0];
				if (file) {
					selectedFileData = file;
					inputFile = file.name;
					updateConvertFileDisplay(inputFile);
					loadFontInfoFromFile(file, 'convert-file-info');
					
					// 自动推断输出目录
					inferOutputDirectory(file.name);
					
					// 启用转换按钮
					const convertBtn = document.getElementById('convertBtn');
					convertBtn.disabled = false;
					
					// 更新结果提示
					updateResult("", "success");
					
					// 获取字重信息
					getFontWeightsFromFile(file);
					
					// 更新按钮文本
					const selectBtn = document.getElementById('selectFileBtn');
					if (selectBtn) {
						selectBtn.textContent = '重新选择';
					}
				}
			}
			
			// 推断输出目录
			function inferOutputDirectory(filename) {
				// 尝试推断原文件可能所在的目录
				const commonDirs = [
					'~/Desktop',
					'~/Downloads', 
					'~/Documents',
					'~/'
				];
				
				// 显示推断的目录（简化显示）
				const outputPathInput = document.getElementById('outputFolderPath');
				if (outputPathInput) {
					outputPathInput.value = '自动检测原文件目录...';
					outputPathInput.title = '将尝试在桌面、下载、文档等目录中查找原文件，并输出到相同目录';
				}
			}
			
			// 拖拽处理函数
			function handleDragOver(event) {
				event.preventDefault();
				event.currentTarget.classList.add('drag-over');
			}
			
			function handleDragLeave(event) {
				event.currentTarget.classList.remove('drag-over');
			}
			
			function handleDrop(event, targetType) {
				event.preventDefault();
				event.currentTarget.classList.remove('drag-over');
				
				const files = event.dataTransfer.files;
				if (files.length > 0) {
					const file = files[0];
					const fileName = file.name.toLowerCase();
					
					// 检查文件类型
					if (fileName.endsWith('.ttf') || fileName.endsWith('.otf') || 
						fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {
						
						if (targetType === 'split-input-file') {
							document.getElementById('split-input-file').value = file.path || file.name;
							loadFontInfo(file.path || file.name, 'split-file-info');
						} else if (targetType === 'convert-input') {
							selectedFileData = file;
							inputFile = file.name;
							updateConvertFileDisplay(inputFile);
							// 使用文件对象获取字体信息
							loadFontInfoFromFile(file, 'convert-file-info');
							
							// 自动推断输出目录
							inferOutputDirectory(file.name);
							
							// 启用转换按钮
							const convertBtn = document.getElementById('convertBtn');
							convertBtn.disabled = false;
							
							// 更新结果提示
							updateResult("", "success");
							
							// 获取字重信息
							if (window.pywebview && window.pywebview.api) {
								window.pywebview.api.get_font_weights(inputFile).then(weights => {
									availableWeights = weights;
									const weightCard = document.getElementById("weightCard");
									const weightOptions = document.getElementById("weightOptions");
									weightOptions.innerHTML = "";
									
									if (weights && weights.length > 0) {
										weightCard.style.display = "block";
										weights.forEach((weight) => {
											const inputId = `weight-${weight}`;
											weightOptions.innerHTML += `
												<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
												<label for="${inputId}">${weight}</label>
											`;
										});
									} else {
										weightCard.style.display = "none";
									}
								});
							}
						}
					} else {
						updateResult('❌ 请选择字体文件 (.ttf, .otf, .woff, .woff2)', 'error');
					}
				}
			}
			
			// 从文件对象加载字体信息
			function loadFontInfoFromFile(file, infoElementId) {
				const reader = new FileReader();
				reader.onload = function(e) {
					const arrayBuffer = e.target.result;
					// 这里可以解析字体文件的基本信息
					// 暂时显示文件基本信息
					const infoEl = document.getElementById(infoElementId);
					infoEl.style.display = 'block';
				};
				reader.readAsArrayBuffer(file);
			}
			
			// 从文件对象获取字重信息
			async function getFontWeightsFromFile(file) {
				const weightCard = document.getElementById("weightCard");
				const weightOptions = document.getElementById("weightOptions");
				
				// 显示加载状态
				weightCard.style.display = "block";
				weightOptions.innerHTML = "<div style='text-align: center; color: #666;'>正在分析字体字重...</div>";
				
				try {
					// 将文件转换为base64
					const fileData = await fileToBase64(file);
					
					// 调用后端API获取字重信息
					if (window.pywebview && window.pywebview.api) {
						const weights = await window.pywebview.api.get_font_weights_from_data(fileData, file.name);
						
						if (weights && weights.length > 0) {
							availableWeights = weights;
							weightOptions.innerHTML = "";
							
							weights.forEach((weight) => {
								const inputId = `weight-${weight}`;
								const weightName = getWeightName(weight);
								weightOptions.innerHTML += `
									<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
									<label for="${inputId}">${weightName}</label>
								`;
							});
						} else {
							// 如果没有检测到字重信息，使用默认值
							availableWeights = [400];
							weightOptions.innerHTML = `
								<input type="checkbox" id="weight-400" name="weight" value="400" checked>
								<label for="weight-400">Regular (400)</label>
							`;
						}
					} else {
						throw new Error('API不可用');
					}
				} catch (error) {
					console.error('获取字重失败:', error);
					// 出错时使用默认字重
					availableWeights = [400];
					weightOptions.innerHTML = `
						<input type="checkbox" id="weight-400" name="weight" value="400" checked>
						<label for="weight-400">Regular (400)</label>
					`;
				}
			}
			
			// 将数字字重转换为可读名称
			function getWeightName(weight) {
				const weightNames = {
					100: 'Thin (100)',
					200: 'Extra Light (200)',
					300: 'Light (300)',
					400: 'Regular (400)',
					500: 'Medium (500)',
					600: 'Semi Bold (600)',
					700: 'Bold (700)',
					800: 'Extra Bold (800)',
					900: 'Black (900)'
				};
				return weightNames[weight] || `${weight}`;
			}
			
			// 加载字体信息（保留原有函数用于拆分功能）
			function loadFontInfo(filePath, infoElementId) {
				if (window.pywebview && window.pywebview.api) {
					const info = window.pywebview.api.get_font_info(filePath);
					if (info.success) {
						const infoEl = document.getElementById(infoElementId);
						infoEl.innerHTML = `
							<div class="font-info">
								<strong>${info.font_family}</strong> - ${info.font_style}<br>
								文件大小: ${info.file_size} | 字符数: ${info.character_count.toLocaleString()}
								${info.is_variable ? '<br><span class="variable-font">🎨 变量字体</span>' : ''}
							</div>
						`;
						infoEl.style.display = 'block';
					}
				}
			}
			
			// 取消处理
			function cancelProcessing() {
				if (window.pywebview && window.pywebview.api) {
					const result = window.pywebview.api.cancel_processing();
					if (result.success) {
						updateResult(result.message, 'success');
						hideStatusBar();
					}
				}
			}
			
			// 状态栏管理
			function showStatusBar(message, showCancel = false) {
				const statusBar = document.getElementById('status-bar');
				const statusText = document.getElementById('status-text');
				const cancelBtn = document.getElementById('cancel-btn');
				
				statusText.textContent = message;
				cancelBtn.style.display = showCancel ? 'block' : 'none';
				statusBar.style.display = 'block';
			}
			
			function hideStatusBar() {
				document.getElementById('status-bar').style.display = 'none';
			}
			
			function updateProgress(percent) {
				const progressFill = document.getElementById('progress-fill');
				progressFill.style.width = percent + '%';
			}
			
			// 更新转换文件显示
			function updateConvertFileDisplay(filePath) {
				const dropZone = document.getElementById('mainDropZone');
				const fileName = filePath.split('/').pop() || filePath.split('\\').pop();
				dropZone.innerHTML = `
					<div class="drop-zone-content file-selected">
						<div class="drop-icon">✅</div>
						<h3>已选择文件</h3>
						<p>${fileName}</p>
					</div>
				`;
				
				// 更新右侧的选择按钮文本
				const selectBtn = document.getElementById('selectFileBtn');
				if (selectBtn) {
					selectBtn.textContent = '重新选择';
				}
				
				// 重新绑定拖拽事件
				dropZone.setAttribute('ondrop', 'handleDrop(event, "convert-input")');
				dropZone.setAttribute('ondragover', 'handleDragOver(event)');
				dropZone.setAttribute('ondragleave', 'handleDragLeave(event)');
			}
			
			// pal包配置
			const PAL_CONFIG = {
				clientId: '1065', // 需要替换为实际的clientId
				path:'activity',
				operate_id: 'web_fontmin_utils',
				retryCount: 1,
				withHash: false,
				hashAlgorithm: 'MD5',
			}

			// 统一字符集定义
			const quickCharSets = {
				"常用(推荐)": "常用字符集",
				全部数字: "0123456789",
				大小写英文: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
				简体中文: "简体中文集",
				繁体中文: "繁体中文集",
				全部日文: "日文字符集",
				全部韩文: "韩文字符集"
			}
			const allUnicodeRanges = {
				常用字符集: (() => {
					const chars = new Set()
					for (let i = 0x0021; i <= 0x007f; i++) chars.add(String.fromCharCode(i))
					for (let i = 0x4e00; i <= 0x9fff; i++) chars.add(String.fromCharCode(i))
					for (let i = 0x3000; i <= 0x303f; i++) chars.add(String.fromCharCode(i))
					for (let i = 0xff00; i <= 0xffef; i++) chars.add(String.fromCharCode(i))
					return Array.from(chars).join("")
				})(),
				简体中文集: Array.from({ length: 0x9fff - 0x4e00 + 1 }, (_, i) => String.fromCharCode(0x4e00 + i)).join(""),
				繁体中文集:
					Array.from({ length: 0x4dbf - 0x3400 + 1 }, (_, i) => String.fromCharCode(0x3400 + i)).join("") +
					Array.from({ length: 0x9fff - 0x4e00 + 1 }, (_, i) => String.fromCharCode(0x4e00 + i)).join(""),
				日文字符集:
					Array.from({ length: 0x309f - 0x3040 + 1 }, (_, i) => String.fromCharCode(0x3040 + i)).join("") +
					Array.from({ length: 0x30ff - 0x30a0 + 1 }, (_, i) => String.fromCharCode(0x30a0 + i)).join("") +
					Array.from({ length: 0x31ff - 0x31f0 + 1 }, (_, i) => String.fromCharCode(0x31f0 + i)).join(""),
				韩文字符集: Array.from({ length: 0xd7a3 - 0xac00 + 1 }, (_, i) => String.fromCharCode(0xac00 + i)).join("")
			}

			function renderQuickCharCheckboxes() {
				const container = document.getElementById("quickCharsContainer")
				container.innerHTML = ""
				Object.entries(quickCharSets).forEach(([label, value], index) => {
					const isDefault = false // 默认不勾选任何字符集，避免误包含全部字符
					const inputId = `quick-char-${index}`
					container.innerHTML += `
                    <label for="${inputId}">
                        <input type="checkbox" id="${inputId}" data-chars="${value}" ${isDefault ? "checked" : ""}>
                        <span class="checkmark"></span>
                        ${label}
                    </label>
                `
				})
			}

			renderQuickCharCheckboxes()

			function updateResult(message, type) {
				const resultDiv = document.getElementById("result")
				resultDiv.innerText = message
				resultDiv.className = `result ${type || "info"}`
			}


			async function getFontWeights(filePath) {
				try {
					// 检查API是否可用
					if (!window.pywebview || !window.pywebview.api) {
						console.log('pywebview API 不可用，跳过字重获取')
						return
					}
					
					const weights = await window.pywebview.api.get_font_weights(filePath)
					availableWeights = weights
					
					const weightCard = document.getElementById("weightCard")
					const weightOptions = document.getElementById("weightOptions")
					weightOptions.innerHTML = ""
					
					if (weights && weights.length > 0) {
						weightCard.style.display = "block"
						weights.forEach((weight) => {
							const inputId = `weight-${weight}`
							weightOptions.innerHTML += `
								<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
								<label for="${inputId}">${weight}</label>
							`
						})
					} else {
						weightCard.style.display = "none"
					}
				} catch (e) {
					console.error('获取字重失败:', e)
					// 如果获取字重失败，隐藏字重选择区域
					document.getElementById("weightCard").style.display = "none"
				}
			}

			async function selectInputFile() {
				console.log('selectInputFile 被调用');
				try {
					updateResult("正在呼叫文件选择窗口，请稍候...", "info")
					
					// 检查API是否可用
					if (!window.pywebview || !window.pywebview.api) {
						console.error('webview API 不可用');
						updateResult("❌ API不可用，请检查应用状态", "error");
						return;
					}
					
					console.log('调用 select_input_file API');
					inputFile = await window.pywebview.api.select_input_file()
					console.log('API 返回结果:', inputFile);
					
					const convertBtn = document.getElementById("convertBtn")
					
					if (inputFile) {
						updateConvertFileDisplay(inputFile)
						convertBtn.disabled = false
						outputFolder = null
						updateResult("", "success")
						
						const weights = await window.pywebview.api.get_font_weights(inputFile)
						availableWeights = weights
						
						const weightCard = document.getElementById("weightCard")
						const weightOptions = document.getElementById("weightOptions")
						weightOptions.innerHTML = ""
						
						if (weights && weights.length > 0) {
							weightCard.style.display = "block"
							weights.forEach((weight) => {
								const inputId = `weight-${weight}`
								weightOptions.innerHTML += `
									<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
									<label for="${inputId}">${weight}</label>
								`
							})
						} else {
							weightCard.style.display = "none"
						}
					} else {
						// 无返回时，不提示"取消"，仅静默恢复
						updateResult("", "info")
						const convertBtn = document.getElementById("convertBtn")
						convertBtn.disabled = true
						document.getElementById("weightCard").style.display = "none"
					}
				} catch (e) {
					console.error('选择输入文件失败:', e)
					updateResult("选择文件失败，请重试。", "error")
				}
			}



			async function startConversion() {
				if (!selectedFileData) {
					updateResult("❌ 请先选择字体文件哦！", "error")
					return
				}

				const selectedFormats = Array.from(document.querySelectorAll(".format-options input:checked")).map(
					(el) => el.value
				)

				console.log("选中的格式:", selectedFormats)
				console.log("所有格式选项:", document.querySelectorAll(".format-options input"))

				if (selectedFormats.length === 0) {
					updateResult("❌ 请至少选择一种输出格式！", "error")
					return
				}

				const subsetChars = document.getElementById("subsetChars").value
				const selectedQuickChars = Array.from(document.querySelectorAll("#quickCharsContainer input:checked")).map(
					(el) => el.getAttribute("data-chars")
				)

				const allChars = Array.from(
					new Set(
						(
							subsetChars +
							selectedQuickChars
								.map((chars) => {
									return allUnicodeRanges[chars] || chars
								})
								.join("")
						).split("")
					)
				).join("")

				const selectedWeights = Array.from(document.querySelectorAll("#weightOptions input:checked")).map(
					(el) => el.value
				)

				const convertBtn = document.getElementById("convertBtn")
				convertBtn.disabled = true

				updateResult("🚀 转换任务已提交，请耐心等待...", "info")

				// 将文件转换为base64发送给后端
				const fileData = await fileToBase64(selectedFileData);
				
				const result = await window.pywebview.api.start_conversion_with_file(
					fileData,
					selectedFileData.name,
					allChars,
					selectedWeights,
					outputFolder,
					selectedFormats
				)

				convertBtn.disabled = false

				if (result.success) {
					let message = `🎉 转换完成！总耗时：${result.total_time_seconds.toFixed(2)} 秒\n`
					if (result.paths && result.paths.length > 0) {
						message += "\n转换后的文件位于：\n" + result.paths.join("\n")
					}
					updateResult(message, "success")
				} else {
					updateResult(result.message, "error")
				}
			}
			
			// 添加拆分文件数据变量
			let splitFileData = null;
			
			function selectSplitInputFile() {
				pywebview.api.select_input_file().then(result => {
					if (result) {
						splitInputFile = result;
						document.getElementById('split-input-file').value = result;
					}
				});
			}

			function selectSplitOutputFolder() {
				pywebview.api.select_output_folder().then(result => {
					if (result) {
						window.splitOutputFolder = result;
						document.getElementById('split-output-folder').value = result;
					}
				});
			}

			function startSplitProcess() {
				console.log('开始拆分字体...');
				console.log('当前全局变量状态:', {
					splitFileData: window.splitFileData,
					splitInputFile: window.splitInputFile,
					selectedLanguage: window.selectedLanguage
				});
				
				const fontFamily = document.getElementById('font-family').value.trim();
				const numChunks = parseInt(document.getElementById('num-chunks').value);

				console.log('参数检查:', {
					splitInputFile: window.splitInputFile,
					fontFamily,
					selectedLanguage: window.selectedLanguage,
					numChunks
				});

				if (!window.splitInputFile) {
					showSplitStatus('error', '请先选择字体文件');
					return;
				}

				if (!fontFamily) {
					showSplitStatus('error', '请输入字体名称');
					return;
				}

				if (!window.selectedLanguage) {
					showSplitStatus('error', '请选择语言类型');
					return;
				}

				// 禁用按钮并初始化进度显示
				document.getElementById('split-button').disabled = true;
				showSplitStatus('info', '开始拆分字体...');
				showSplitProgress(0);
				showTaskStatus('正在拆分字体...', '请稍候', true);

				// 开始进度轮询
				let progressInterval = null;
				
				function startProgressPolling() {
					progressInterval = setInterval(async () => {
						try {
							const progress = await pywebview.api.get_progress();
							console.log('进度更新:', progress);
							
							if (progress.is_running) {
								// 格式化时间信息
								const timeInfo = `
									<div class="time-info">
										<span>⏱️ 已用: ${progress.elapsed_time}</span>
										<span>⏳ 剩余: ${progress.remaining_time}</span>
										<span>📊 ${progress.current}/${progress.total}</span>
									</div>
								`;
								
								// 更新任务状态
								showTaskStatus(
									progress.message,
									timeInfo,
									true
								);
								
								// 更新进度条
								updateTaskProgress(progress.percent);
                            } else if (progress.step === 'completed') {
                                // 完成时停止轮询并准备隐藏状态卡片
                                clearInterval(progressInterval);
                                progressInterval = null;
                                setTimeout(() => hideTaskStatus(), 1000);
                            }
						} catch (error) {
							console.error('获取进度失败:', error);
						}
					}, 500); // 每500ms轮询一次
				}
				
				function stopProgressPolling() {
					if (progressInterval) {
						clearInterval(progressInterval);
						progressInterval = null;
					}
				}

				// 开始进度轮询
				startProgressPolling();

				// 调用Python API
				if (window.splitFileData) {
					// 使用文件数据
					fileToBase64(window.splitFileData).then(fileData => {
						return pywebview.api.split_font_and_generate_css_with_file(
							fileData,
							window.splitFileData.name,
							fontFamily,
							window.selectedLanguage,
							numChunks,
							window.splitOutputFolder || null
						);
					}).then(result => {
					// 停止进度轮询
					stopProgressPolling();
					console.log('拆分完成，返回结果:', result);
					document.getElementById('split-button').disabled = false;
					
                    if (result && result.success) {
                        // 展示完成提示卡片，并在4秒后自动收起
                        const successDetail = `
                            <div class="status-badges">
                                <span class="badge success">🎉 完成</span>
                                <span class="badge info">📦 子集: ${result.subset_count}</span>
                                <span class="badge path" title="点击复制">📃 CSS 路径</span>
                            </div>
                            <div style="margin-top:8px;font-size:12px;color:#595959;">${result.css_path}</div>
                            <div class="task-actions" style="margin-top:10px;">
                                <button class="mini-button" id="copyCssPathBtn">复制 CSS 路径</button>
                            </div>
                        `;
                        showTaskStatus('拆分与上传完成', successDetail, false);
                        // 复制按钮
                        setTimeout(() => {
                            const btn = document.getElementById('copyCssPathBtn');
                            if (btn) {
                                btn.onclick = () => {
                                    navigator.clipboard.writeText(result.css_path).then(() => {
                                        btn.textContent = '已复制';
                                        setTimeout(() => (btn.textContent = '复制 CSS 路径'), 1500);
                                    });
                                };
                            }
                        }, 0);
                        // 再保险：结果返回后也安排自动隐藏
                        setTimeout(() => hideTaskStatus(), 4000);
						
						// 同时展示结果列表
						showSplitResults([
							`CSS文件: ${result.css_path}`,
							`子集数量: ${result.subset_count}`,
							`输出目录: ${result.output_folder}`
						]);
					} else {
						console.error('任务失败或返回空结果:', result);
						showSplitStatus('error', (result && result.message) ? result.message : '任务失败，返回结果为空');
						hideSplitProgress();
						// 失败时保留状态卡片，便于查看原因
					}
                }).catch(error => {
					// 停止进度轮询
					stopProgressPolling();
					document.getElementById('split-button').disabled = false;
					console.error('处理过程中发生错误:', error);
					showSplitStatus('error', '处理过程中发生错误: ' + error);
					hideSplitProgress();
					// 错误时保留状态卡片
				});
			}

			function showSplitStatus(type, message) {
				// 使用任务状态显示消息
				showTaskStatus(message, '', false);
			}

			function showSplitProgress(percent) {
				// 使用任务进度显示
				updateTaskProgress(percent);
			}

			function hideSplitProgress() {
				// 不需要隐藏，任务状态会统一管理
			}

			// 任务进度管理函数
			function showTaskStatus(title, detail = '', showProgress = false) {
				const taskStatusEl = document.getElementById('task-status');
				const titleEl = document.getElementById('task-status-title');
				const detailEl = document.getElementById('task-status-detail');
				const progressEl = document.getElementById('task-progress');
				
				titleEl.textContent = title;
				
				// 支持HTML内容，且兼容非字符串
				if (typeof detail === 'string' && detail.indexOf('<') >= 0) {
					detailEl.innerHTML = detail;
				} else {
					detailEl.textContent = (detail || '').toString();
				}
				
				taskStatusEl.style.display = 'block';
				
				if (showProgress) {
					progressEl.style.display = 'block';
				} else {
					progressEl.style.display = 'none';
				}
			}

			function hideTaskStatus() {
				document.getElementById('task-status').style.display = 'none';
			}

			function updateTaskProgress(percent) {
				const progressBar = document.getElementById('task-progress-bar');
				progressBar.style.width = percent + '%';
			}


			function showSplitResults(results) {
				const resultsEl = document.getElementById('split-results');
				resultsEl.innerHTML = results.map(result => 
					`<div class="result-item">${result}</div>`
				).join('');
				resultsEl.style.display = 'block';
			}

			// 使用momo包的上传函数
			async function uploadToCDN(filePath, filename, language) {
				try {
					console.log('🔍 uploadToCDN 开始执行:');
					console.log('  - filePath:', filePath);
					console.log('  - filename:', filename);
					console.log('  - language:', language);
					
					// 检查 fileUpload 函数是否存在
					if (typeof window.fileUpload !== 'function') {
						throw new Error('fileUpload 函数不存在');
					}
					console.log('✅ fileUpload 函数存在');
					
					// 创建一个模拟的File对象，不需要实际读取文件
					const mockFile = new File([''], filename, { type: 'application/octet-stream' });
					console.log('✅ 模拟File对象创建成功:', mockFile.name);
					
					// 使用模拟的fileUpload函数
					console.log('🔍 开始模拟上传...');
					const result = await window.fileUpload({
						clientId: '1065',
						file: [mockFile], // 文件数组
						path: 'activity',
						operate_id: 'web_fontmin_utils',
						retryCount: 1,
						withHash: false,
						hashAlgorithm: 'MD5',
						onProgress: (percent) => {
							console.log(`上传进度: ${Math.round(percent * 100)}%`);
						},
						onSingleFinish: (res, index) => {
							console.log('单个文件上传完成:', res);
						}
					});
					
					console.log('🔍 上传结果:', result);
					
					// 返回第一个文件的URL
					if (result && result.files && result.files.length > 0 && result.files[0].success) {
						const url = result.files[0].resourceUrl;
						console.log('✅ 上传成功，返回URL:', url);
						return url;
					} else {
						throw new Error('上传失败，结果:', result);
					}
					
				} catch (error) {
					console.error('❌ uploadToCDN 失败:', error);
					throw error;
				}
			}

			// 初始化
				document.addEventListener('DOMContentLoaded', function() {
				selectLanguage('zh'); // 默认选择简体中文
			});
		</script>
	</body>
	<script type="module">
		// ===== CDN 上传解决方案 =====
		// 直接使用 Python 后端上传，无需前端 fileUpload 函数
		//
		console.log('🔍 CDN 上传由 Python 后端直接处理');
		console.log('💡 无需前端 fileUpload 函数，所有上传逻辑在 Python 后端');
	</script>
</html>

