<!DOCTYPE html>
<html>
	<head>
		<title>FontTool</title>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="styles.css">
		<script>
			// æ ‡ç­¾é¡µåˆ‡æ¢å‡½æ•°
			function switchTab(tabName) {
				console.log('å¼€å§‹åˆ‡æ¢æ ‡ç­¾é¡µ:', tabName);
				
				// éšè—æ‰€æœ‰æ ‡ç­¾é¡µå†…å®¹
				const convertTab = document.getElementById('convert-tab');
				const splitTab = document.getElementById('split-tab');
				
				console.log('convert-tab:', convertTab);
				console.log('split-tab:', splitTab);
				
				// ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„activeç±»
				const tabs = document.querySelectorAll('.tab');
				tabs.forEach(tab => {
					tab.classList.remove('active');
				});
				
				// æ ¹æ®tabNameåˆ‡æ¢
				if (tabName === 'convert') {
					if (convertTab) convertTab.classList.add('active');
					if (splitTab) splitTab.classList.remove('active');
					// ä¸ºå¯¹åº”çš„æŒ‰é’®æ·»åŠ activeç±»
					const convertBtn = document.querySelector('[onclick="switchTab(\'convert\')"]');
					if (convertBtn) convertBtn.classList.add('active');
					console.log('åˆ‡æ¢åˆ°æ ¼å¼è½¬æ¢');
				} else if (tabName === 'split') {
					if (convertTab) convertTab.classList.remove('active');
					if (splitTab) splitTab.classList.add('active');
					// ä¸ºå¯¹åº”çš„æŒ‰é’®æ·»åŠ activeç±»
					const splitBtn = document.querySelector('[onclick="switchTab(\'split\')"]');
					if (splitBtn) splitBtn.classList.add('active');
					console.log('åˆ‡æ¢åˆ°å­—ä½“æ‹†åˆ†');
				}
				
				console.log('æ ‡ç­¾é¡µåˆ‡æ¢å®Œæˆ');
			}
			
			// å¤„ç†æ‹†åˆ†æ–‡ä»¶é€‰æ‹©
		function handleSplitFileSelect(event) {
			console.log('æ–‡ä»¶é€‰æ‹©è¢«è§¦å‘:', event);
			const file = event.target.files[0];
			console.log('é€‰æ‹©çš„æ–‡ä»¶:', file);
			if (file) {
				// æ·»åŠ æ–‡ä»¶ç±»å‹æ ¡éªŒï¼Œä¸æ‹–æ‹½å¤„ç†ä¿æŒä¸€è‡´
				const fileName = file.name.toLowerCase();
				if (!fileName.endsWith('.ttf') && !fileName.endsWith('.otf') && 
					!fileName.endsWith('.woff') && !fileName.endsWith('.woff2')) {
					updateResult('âŒ è¯·é€‰æ‹©å­—ä½“æ–‡ä»¶ (.ttf, .otf, .woff, .woff2)', 'error');
					return;
				}
				
				// å­˜å‚¨æ–‡ä»¶å¯¹è±¡ï¼Œç”¨äºåç»­å¤„ç†
				window.splitFileData = file;
				window.splitInputFile = file.name; // å­˜å‚¨æ–‡ä»¶å
				document.getElementById('split-input-file').value = file.name;
				
				console.log('æ–‡ä»¶ä¿¡æ¯å·²æ›´æ–°:', file.name);
				
				// æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
				const infoEl = document.getElementById('split-file-info');
				infoEl.innerHTML = `
					<div class="font-info">
						<strong>${file.name}</strong><br>
						æ–‡ä»¶å¤§å°: ${(file.size / 1024).toFixed(1)} KB
					</div>
				`;
				infoEl.style.display = 'block';
				console.log('æ–‡ä»¶ä¿¡æ¯å·²æ˜¾ç¤º');
			} else {
				console.log('æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
			}
		}
			
			// é€‰æ‹©è¯­è¨€
			function selectLanguage(lang) {
				window.selectedLanguage = lang;
				document.querySelectorAll('.language-option').forEach(option => {
					option.classList.remove('selected');
				});
				document.querySelector(`[data-lang="${lang}"]`).classList.add('selected');
			}
			
			// æ–‡ä»¶è½¬base64å‡½æ•°
			function fileToBase64(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.readAsDataURL(file);
					reader.onload = () => resolve(reader.result);
					reader.onerror = error => reject(error);
				});
			}
			
			// å¼€å§‹æ‹†åˆ†å¤„ç†
		function startSplitProcess() {
			console.log('å¼€å§‹æ‹†åˆ†å­—ä½“...');
			
			const fontFamily = document.getElementById('font-family').value.trim();
			const numChunks = parseInt(document.getElementById('num-chunks').value);

			// å‚æ•°éªŒè¯
			if (!window.splitInputFile) {
				updateResult('è¯·å…ˆé€‰æ‹©å­—ä½“æ–‡ä»¶', 'error');
				return;
			}

			if (!fontFamily) {
				updateResult('è¯·è¾“å…¥å­—ä½“åç§°', 'error');
				return;
			}

			if (!window.selectedLanguage) {
				updateResult('è¯·é€‰æ‹©è¯­è¨€ç±»å‹', 'error');
				return;
			}

			// ç¦ç”¨æŒ‰é’®å¹¶æ˜¾ç¤ºè¿›åº¦
			const splitButton = document.getElementById('split-button');
			splitButton.disabled = true;
			splitButton.textContent = 'æ‹†åˆ†ä¸­...';
			
			// å¼€å§‹æ—¶é—´è®°å½•
			const startTime = Date.now();
			let progressInterval = null;
			
			// æ˜¾ç¤ºè¿›åº¦çŠ¶æ€
			showTaskStatus('å­—ä½“æ‹†åˆ†', 'æ­£åœ¨åˆ†æå­—ä½“æ–‡ä»¶...', true);
			updateResult('å¼€å§‹æ‹†åˆ†å­—ä½“ï¼Œè¯·ç¨å€™...', 'info');

			// è¿›åº¦è½®è¯¢å‡½æ•°
			function updateProgress() {
				const elapsed = Math.floor((Date.now() - startTime) / 1000);
				const minutes = Math.floor(elapsed / 60);
				const seconds = elapsed % 60;
				
				// æ ¹æ®å·²ç”¨æ—¶é—´ä¼°ç®—å‰©ä½™æ—¶é—´ï¼ˆç»éªŒå€¼ï¼‰
				let estimatedTotal = 30; // é»˜è®¤30ç§’
				if (numChunks > 5) estimatedTotal = 45;
				if (numChunks > 10) estimatedTotal = 60;
				
				const remaining = Math.max(0, estimatedTotal - elapsed);
				const remainingMinutes = Math.floor(remaining / 60);
				const remainingSeconds = remaining % 60;
				
				const timeInfo = `
					<div class="time-info">
						<span>â±ï¸ å·²ç”¨: ${minutes > 0 ? minutes + 'åˆ†' : ''}${seconds}ç§’</span>
						<span>â³ é¢„è®¡å‰©ä½™: ${remainingMinutes > 0 ? remainingMinutes + 'åˆ†' : ''}${remainingSeconds}ç§’</span>
						<span>ğŸ“Š å¤„ç†ä¸­...</span>
					</div>
				`;
				
				showTaskStatus('å­—ä½“æ‹†åˆ†è¿›è¡Œä¸­', timeInfo, true);
			}

			// å¼€å§‹è¿›åº¦è½®è¯¢
			progressInterval = setInterval(updateProgress, 1000);

			// è°ƒç”¨Python API
			if (window.splitFileData) {
				fileToBase64(window.splitFileData).then(fileData => {
					return pywebview.api.split_font_and_generate_css_with_file(
						fileData,
						window.splitFileData.name,
						fontFamily,
						window.selectedLanguage,
						numChunks,
						window.splitOutputFolder || null
					);
				}).then(result => {
					console.log('æ‹†åˆ†å®Œæˆï¼Œè¿”å›ç»“æœ:', result);
					
					// åœæ­¢è¿›åº¦è½®è¯¢
					if (progressInterval) {
						clearInterval(progressInterval);
						progressInterval = null;
					}
					
					// æ¢å¤æŒ‰é’®
					splitButton.disabled = false;
					splitButton.textContent = 'å¼€å§‹æ‹†åˆ†å’Œä¸Šä¼ ';
					
					// è®¡ç®—å®é™…ç”¨æ—¶
					const totalTime = Math.floor((Date.now() - startTime) / 1000);
					const minutes = Math.floor(totalTime / 60);
					const seconds = totalTime % 60;
					const timeStr = minutes > 0 ? `${minutes}åˆ†${seconds}ç§’` : `${seconds}ç§’`;
					
					if (result && result.success) {
						// æ˜¾ç¤ºè¯¦ç»†çš„æˆåŠŸä¿¡æ¯
						const successDetail = `
							<div class="success-details">
								<div class="success-badges">
									<span class="badge success">ğŸ‰ æ‹†åˆ†å®Œæˆ</span>
									<span class="badge info">ğŸ“¦ ${result.subset_count} ä¸ªå­é›†</span>
									<span class="badge time">â±ï¸ ç”¨æ—¶ ${timeStr}</span>
								</div>
								<div class="success-info">
									<p>âœ… æˆåŠŸç”Ÿæˆäº† ${result.subset_count} ä¸ªå­é›†å­—ä½“æ–‡ä»¶</p>
									<p>ğŸ“„ CSSæ–‡ä»¶å·²ç”Ÿæˆå¹¶ä¸Šä¼ åˆ°CDN</p>
									${result.css_path ? `<p>ğŸ“ æ–‡ä»¶è·¯å¾„: ${result.css_path}</p>` : ''}
								</div>
								<div class="success-actions">
									<button class="mini-button" onclick="copyToClipboard('${result.css_path || ''}')">å¤åˆ¶CSSè·¯å¾„</button>
								</div>
							</div>
						`;
						
						showTaskStatus('æ‹†åˆ†ä¸ä¸Šä¼ å®Œæˆ', successDetail, false);
						updateResult(`âœ… æ‹†åˆ†å®Œæˆï¼ç”¨æ—¶ ${timeStr}ï¼Œç”Ÿæˆäº† ${result.subset_count} ä¸ªå­é›†å­—ä½“`, 'success');
						
						// ä¿æŒç»“æœå±•ç¤ºï¼Œç›´åˆ°ç”¨æˆ·æ‰‹åŠ¨å…³é—­
					} else {
						hideTaskStatus();
						updateResult('âŒ æ‹†åˆ†å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'), 'error');
					}
				}).catch(error => {
					console.error('æ‹†åˆ†è¿‡ç¨‹ä¸­å‡ºé”™:', error);
					
					// åœæ­¢è¿›åº¦è½®è¯¢
					if (progressInterval) {
						clearInterval(progressInterval);
						progressInterval = null;
					}
					
					// æ¢å¤æŒ‰é’®
					splitButton.disabled = false;
					splitButton.textContent = 'å¼€å§‹æ‹†åˆ†å’Œä¸Šä¼ ';
					
					// éšè—è¿›åº¦çŠ¶æ€
					hideTaskStatus();
					
					updateResult('âŒ æ‹†åˆ†è¿‡ç¨‹ä¸­å‡ºé”™: ' + error.message, 'error');
				});
			} else {
				updateResult('âŒ æ–‡ä»¶æ•°æ®ä¸¢å¤±ï¼Œè¯·é‡æ–°é€‰æ‹©æ–‡ä»¶', 'error');
				splitButton.disabled = false;
				splitButton.textContent = 'å¼€å§‹æ‹†åˆ†å’Œä¸Šä¼ ';
			}
		}
		
		// å¤åˆ¶åˆ°å‰ªè´´æ¿å‡½æ•°
		function copyToClipboard(text) {
			if (navigator.clipboard && navigator.clipboard.writeText) {
				navigator.clipboard.writeText(text).then(() => {
					updateResult('ğŸ“‹ CSSè·¯å¾„å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
				}).catch(err => {
					console.error('å¤åˆ¶å¤±è´¥:', err);
					updateResult('âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
				});
			} else {
				// é™çº§æ–¹æ¡ˆ
				const textArea = document.createElement('textarea');
				textArea.value = text;
				document.body.appendChild(textArea);
				textArea.select();
				try {
					document.execCommand('copy');
					updateResult('ğŸ“‹ CSSè·¯å¾„å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
				} catch (err) {
					console.error('å¤åˆ¶å¤±è´¥:', err);
					updateResult('âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
				}
				document.body.removeChild(textArea);
			}
		}
		</script>
	</head>

	<body>
		<div class="container">
			<!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ -->
			<div id="status-bar" class="status-bar" style="display: none;">
				<div class="status-content">
					<span id="status-icon">â³</span>
					<span id="status-text">å¤„ç†ä¸­...</span>
					<button id="cancel-btn" class="cancel-btn" onclick="cancelProcessing()" style="display: none;">å–æ¶ˆ</button>
				</div>
				<div id="progress-bar" class="progress-bar">
					<div id="progress-fill" class="progress-fill"></div>
				</div>
			</div>
			
			<div class="tabs">
				<button class="tab active" onclick="switchTab('convert')">æ ¼å¼è½¬æ¢</button>
				<button class="tab" onclick="switchTab('split')">å­—ä½“æ‹†åˆ†</button>
			</div>

			<!-- å­—ä½“æ‹†åˆ†æ ‡ç­¾é¡µ -->
			<div id="split-tab" class="tab-content">
				<h2>è¿™é‡Œå¯ä»¥æ‹†åˆ†å­—ä½“å¹¶ä¸Šä¼ åˆ°CDN ä½ å°†å¾—åˆ°ä¸€ä¸ªcssæ–‡ä»¶ğŸ“ƒ</h2>
				
				<div class="form-group">
					<label for="split-input-file">é€‰æ‹©å­—ä½“æ–‡ä»¶ (.ttf, .otf, .woff, .woff2)</label>
					<div class="input-group drop-zone" id="split-drop-zone" ondrop="handleDrop(event, 'split-input-file')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
						<input type="text" id="split-input-file" placeholder="è¯·é€‰æ‹©å­—ä½“æ–‡ä»¶æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„" readonly>
						<input type="file" id="splitFileInput" accept=".ttf,.otf,.woff,.woff2" style="display: none;" onchange="handleSplitFileSelect(event)">
						<button class="button secondary" onclick="console.log('ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æŒ‰é’®'); document.getElementById('splitFileInput').click();">é€‰æ‹©æ–‡ä»¶</button>
					</div>
					<div id="split-file-info" class="file-info" style="display: none;"></div>
				</div>

				<div class="form-group">
					<label for="font-family">å­—ä½“åç§° (font-family)</label>
					<input type="text" id="font-family" placeholder="è¯·è¾“å…¥å­—ä½“åç§°ï¼Œä¾‹å¦‚: MyFont">
				</div>       

				<div class="form-group">
					<label>é€‰æ‹©è¯­è¨€ç±»å‹</label>
					<div class="language-options">
						<div class="language-option" data-lang="zh" onclick="selectLanguage('zh')">
							<strong>ç®€ä½“ä¸­æ–‡</strong>
						</div>
						<div class="language-option" data-lang="tc" onclick="selectLanguage('tc')">
							<strong>ç¹ä½“ä¸­æ–‡</strong>
						</div>
						<div class="language-option" data-lang="ja" onclick="selectLanguage('ja')">
							<strong>æ—¥æ–‡</strong>
						</div>
					</div>
				</div>

				<div class="form-group">
					<label for="num-chunks">æ‹†åˆ†æ•°é‡</label>
					<input type="number" id="num-chunks" value="200" min="1" max="1000" placeholder="å»ºè®®å€¼ï¼š200-500">
				</div>

				<div class="form-group">
					<label for="split-output-folder">è¾“å‡ºæ–‡ä»¶å¤¹ï¼ˆå¯é€‰ï¼‰</label>
					<div class="input-group">
						<input type="text" id="split-output-folder" placeholder="ç•™ç©ºåˆ™è¾“å‡ºåˆ°æ¡Œé¢" readonly>
						<button class="button secondary" onclick="selectSplitOutputFolder()">é€‰æ‹©æ–‡ä»¶å¤¹</button>
					</div>
				</div>

				<button class="button" onclick="startSplitProcess()" id="split-button">å¼€å§‹æ‹†åˆ†å’Œä¸Šä¼ </button>

				<!-- ç®€åŒ–çš„ä»»åŠ¡çŠ¶æ€æ˜¾ç¤º -->
				<div id="task-status" class="task-status" style="display: none;">
					<div class="task-status-content">
						<div class="task-status-icon" id="task-status-icon">â³</div>
						<div class="task-status-text">
							<div class="task-status-title" id="task-status-title">å‡†å¤‡ä¸­...</div>
							<div class="task-status-detail" id="task-status-detail">è¯·ç¨å€™</div>
						</div>
					</div>
					<div id="task-progress" class="progress" style="display: none;">
						<div class="progress-bar" id="task-progress-bar"></div>
					</div>
				</div>
				
				<div id="split-results" class="result-list" style="display: none;"></div>
			</div>

			<!-- æ ¼å¼è½¬æ¢æ ‡ç­¾é¡µ -->
			<div id="convert-tab" class="tab-content active">
				<h2>å­—ä½“æ ¼å¼è½¬æ¢</h2>
				
				<!-- æ–‡ä»¶é€‰æ‹©åŒºåŸŸ -->
				<div class="main-drop-zone" id="mainDropZone" ondrop="handleDrop(event, 'convert-input')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
					<div class="drop-zone-content">
						<div class="drop-icon">ğŸ“</div>
						<h3>æ‹–æ‹½å­—ä½“æ–‡ä»¶åˆ°æ­¤å¤„</h3>
						<p>æ”¯æŒ TTFã€OTFã€WOFFã€WOFF2 æ ¼å¼</p>
					</div>
					<div id="convert-file-info" class="file-info" style="display: none;"></div>
				</div>

				<!-- æ–‡ä»¶é€‰æ‹©åŒºåŸŸ -->
				<div class="file-selection-area">
					<input type="file" id="fileInput" accept=".ttf,.otf,.woff,.woff2" style="display: none;" onchange="handleFileSelect(event)">
					<button class="select-file-btn" id="selectFileBtn" onclick="document.getElementById('fileInput').click()">é€‰æ‹©æ–‡ä»¶</button>
				</div>

				<!-- é…ç½®é€‰é¡¹åŒºåŸŸ -->
				<div class="config-section">
					<div class="config-grid two-column">
						<!-- è¾“å‡ºä½ç½® -->
						<div class="config-item">
							<label>è¾“å‡ºä½ç½®</label>
							<div class="output-folder-section">
								<input type="text" id="outputFolderPath" placeholder="é»˜è®¤è¾“å‡ºåˆ°æ¡Œé¢" readonly>
								<button type="button" id="selectOutputBtn" onclick="selectOutputFolder()">é€‰æ‹©ç›®å½•</button>
							</div>
						</div>
						
						<!-- è¾“å‡ºæ ¼å¼ -->
						<div class="config-item">
							<label>è¾“å‡ºæ ¼å¼</label>
							<div class="format-options">
								<label class="format-option">
									<input type="checkbox" id="format-woff2" name="format" value="woff2" checked />
									<span>WOFF2</span>
								</label>
								<label class="format-option">
									<input type="checkbox" id="format-woff" name="format" value="woff" />
									<span>WOFF</span>
								</label>
							</div>
						</div>

						<!-- å­—ç¬¦å­é›† -->
						<div class="config-item full-width">
							<label>å­—ç¬¦å­é›†ï¼ˆå¯é€‰ï¼‰</label>
							<p class="help-text">è¿™èƒ½å¤§å¤§å‡å°å­—ä½“æ–‡ä»¶ä½“ç§¯</p>
							<div id="quickCharsContainer" class="checkbox-group"></div>
							<textarea
								id="subsetChars"
								rows="2"
								placeholder="è¾“å…¥æˆ–ç²˜è´´è‡ªå®šä¹‰æ–‡æœ¬ï¼Œæˆ‘ä»¬ä¼šå°†ä½ è¾“å…¥çš„å­—ç¬¦ä¸å¿«æ·é€‰é¡¹è¿›è¡Œåˆå¹¶..."
							></textarea>
						</div>

						<!-- å­—é‡é€‰æ‹© -->
						<div class="config-item full-width" id="weightCard" style="display: none">
							<label>å­—é‡é€‰æ‹©ï¼ˆå¯å˜å­—ä½“ï¼‰</label>
							<p class="help-text">è¯¥å­—ä½“ä¸ºå¯å˜å­—ä½“ï¼Œè¯·é€‰æ‹©éœ€è¦å¯¼å‡ºçš„å­—é‡ç‰ˆæœ¬</p>
							<div id="weightOptions" class="weight-options"></div>
						</div>
					</div>
				</div>


				<!-- è½¬æ¢æŒ‰é’®åŒºåŸŸ -->
				<div class="convert-section">
					<button id="convertBtn" class="convert-btn" onclick="startConversion()" disabled>
						<span class="btn-icon">ğŸš€</span>
						<span class="btn-text">å¼€å§‹è½¬æ¢</span>
					</button>
					<div id="result" class="result info">è¯·å…ˆé€‰æ‹©å­—ä½“æ–‡ä»¶</div>
				</div>
			</div>
		</div>

		<script>
			let inputFile = null
			let outputFolder = null
			let availableWeights = []
			let selectedFileData = null // å­˜å‚¨æ–‡ä»¶å¯¹è±¡
			
			// å­—ä½“æ‹†åˆ†ç›¸å…³å˜é‡
			let splitInputFile = ''
			window.splitOutputFolder = ''
			let selectedLanguage = 'zh'
			
			// æ–‡ä»¶è½¬base64å‡½æ•°
			// é€‰æ‹©è¾“å‡ºç›®å½•
			async function selectOutputFolder() {
				try {
					if (window.pywebview && window.pywebview.api) {
						const folder = await window.pywebview.api.select_output_folder();
						if (folder) {
							document.getElementById('outputFolderPath').value = folder;
							outputFolder = folder;
						}
					} else {
						updateResult("âŒ APIä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥åº”ç”¨çŠ¶æ€", "error");
					}
				} catch (error) {
					updateResult(`âŒ é€‰æ‹©ç›®å½•å¤±è´¥: ${error.message}`, "error");
				}
			}
			
			// æ–‡ä»¶é€‰æ‹©å¤„ç†å‡½æ•°
		function handleFileSelect(event) {
			const file = event.target.files[0];
			if (file) {
				// æ·»åŠ æ–‡ä»¶ç±»å‹æ ¡éªŒï¼Œä¸æ‹–æ‹½å¤„ç†ä¿æŒä¸€è‡´
				const fileName = file.name.toLowerCase();
				if (!fileName.endsWith('.ttf') && !fileName.endsWith('.otf') && 
					!fileName.endsWith('.woff') && !fileName.endsWith('.woff2')) {
					updateResult('âŒ è¯·é€‰æ‹©å­—ä½“æ–‡ä»¶ (.ttf, .otf, .woff, .woff2)', 'error');
					return;
				}
				
				selectedFileData = file;
				inputFile = file.name;
				updateConvertFileDisplay(inputFile);
				loadFontInfoFromFile(file, 'convert-file-info');
				
				// è‡ªåŠ¨æ¨æ–­è¾“å‡ºç›®å½•
				inferOutputDirectory(file.name);
				
				// å¯ç”¨è½¬æ¢æŒ‰é’®
				const convertBtn = document.getElementById('convertBtn');
				convertBtn.disabled = false;
				
				// æ›´æ–°ç»“æœæç¤º
				updateResult("", "success");
				
				// è·å–å­—é‡ä¿¡æ¯
				getFontWeightsFromFile(file);
					
					// æ›´æ–°æŒ‰é’®æ–‡æœ¬
					const selectBtn = document.getElementById('selectFileBtn');
					if (selectBtn) {
						selectBtn.textContent = 'é‡æ–°é€‰æ‹©';
					}
				}
			}
			
			// æ¨æ–­è¾“å‡ºç›®å½•
			function inferOutputDirectory(filename) {
				// å°è¯•æ¨æ–­åŸæ–‡ä»¶å¯èƒ½æ‰€åœ¨çš„ç›®å½•
				const commonDirs = [
					'~/Desktop',
					'~/Downloads', 
					'~/Documents',
					'~/'
				];
				
				// æ˜¾ç¤ºæ¨æ–­çš„ç›®å½•ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
				const outputPathInput = document.getElementById('outputFolderPath');
				if (outputPathInput) {
					outputPathInput.value = 'è‡ªåŠ¨æ”¾åˆ°æ¡Œé¢ä¸Š';
					outputPathInput.title = 'å°†å°è¯•åœ¨æ¡Œé¢ã€ä¸‹è½½ã€æ–‡æ¡£ç­‰ç›®å½•ä¸­æŸ¥æ‰¾åŸæ–‡ä»¶ï¼Œå¹¶è¾“å‡ºåˆ°ç›¸åŒç›®å½•';
				}
			}
			
			// æ‹–æ‹½å¤„ç†å‡½æ•°
			function handleDragOver(event) {
				// å…è®¸æ”¾ç½®
				event.preventDefault();
				event.stopPropagation();
				if (event.dataTransfer) {
					event.dataTransfer.dropEffect = 'copy';
				}
				event.currentTarget.classList.add('drag-over');
			}
			
			function handleDragLeave(event) {
				event.stopPropagation();
				event.currentTarget.classList.remove('drag-over');
			}
			
			function handleDrop(event, targetType) {
				// é˜»æ­¢é»˜è®¤è¡Œä¸º
				event.preventDefault();
				event.stopPropagation();
				event.currentTarget.classList.remove('drag-over');
				
				const files = event.dataTransfer.files;
				if (files.length > 0) {
					const file = files[0];
					const fileName = file.name.toLowerCase();
					
					// æ£€æŸ¥æ–‡ä»¶ç±»å‹
					if (fileName.endsWith('.ttf') || fileName.endsWith('.otf') || 
						fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {
						
						if (targetType === 'split-input-file') {
							// æ”¯æŒæ‹†åˆ†é¡µæ‹–æ‹½ï¼šä¿å­˜æ–‡ä»¶å¯¹è±¡ä¸åç§°ï¼Œå±•ç¤ºæ–‡ä»¶ä¿¡æ¯
							window.splitFileData = file;
							window.splitInputFile = file.name;
							document.getElementById('split-input-file').value = file.name;
							// ä½¿ç”¨æ–‡ä»¶å¯¹è±¡å±•ç¤ºåŸºç¡€ä¿¡æ¯ï¼ˆåç§°ã€å¤§å°ï¼‰Â·
							if (typeof loadFontInfoFromFile === 'function') {
								loadFontInfoFromFile(file, 'split-file-info');
							} else {
								const infoEl = document.getElementById('split-file-info');
								if (infoEl) {
									infoEl.innerHTML = `
										<div class="font-info">
											<strong>${file.name}</strong><br>
											æ–‡ä»¶å¤§å°: ${(file.size / 1024).toFixed(1)} KB
										</div>
									`;
									infoEl.style.display = 'block';
								}
							}
							// å¯ç”¨â€œå¼€å§‹æ‹†åˆ†â€æŒ‰é’®
							const splitBtn = document.getElementById('split-button');
							if (splitBtn) splitBtn.disabled = false;
							// ç»“æœæç¤º
							if (typeof updateResult === 'function') {
								updateResult('âœ… å·²é€‰æ‹©æ‹†åˆ†å­—ä½“æ–‡ä»¶ï¼š' + file.name, 'success');
							}
						} else if (targetType === 'convert-input') {
							selectedFileData = file;
							inputFile = file.name;
							updateConvertFileDisplay(inputFile);
							// ä½¿ç”¨æ–‡ä»¶å¯¹è±¡è·å–å­—ä½“ä¿¡æ¯
							loadFontInfoFromFile(file, 'convert-file-info');
							
							// è‡ªåŠ¨æ¨æ–­è¾“å‡ºç›®å½•
							inferOutputDirectory(file.name);
							
							// å¯ç”¨è½¬æ¢æŒ‰é’®
							const convertBtn = document.getElementById('convertBtn');
							convertBtn.disabled = false;
							
							// æ›´æ–°ç»“æœæç¤º
							updateResult("", "success");
							
							// è·å–å­—é‡ä¿¡æ¯
							if (window.pywebview && window.pywebview.api) {
								window.pywebview.api.get_font_weights(inputFile).then(weights => {
									availableWeights = weights;
									const weightCard = document.getElementById("weightCard");
									const weightOptions = document.getElementById("weightOptions");
									weightOptions.innerHTML = "";
									
									if (weights && weights.length > 0) {
										weightCard.style.display = "block";
										weights.forEach((weight) => {
											const inputId = `weight-${weight}`;
											weightOptions.innerHTML += `
												<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
												<label for="${inputId}">${weight}</label>
											`;
										});
									} else {
										weightCard.style.display = "none";
									}
								});
							}
						}
					} else {
						updateResult('âŒ è¯·é€‰æ‹©å­—ä½“æ–‡ä»¶ (.ttf, .otf, .woff, .woff2)', 'error');
					}
				}
			}
			
			// ä»æ–‡ä»¶å¯¹è±¡åŠ è½½å­—ä½“ä¿¡æ¯
			function loadFontInfoFromFile(file, infoElementId) {
				const infoEl = document.getElementById(infoElementId);
				if (infoEl) {
					// æ˜¾ç¤ºæ–‡ä»¶åŸºæœ¬ä¿¡æ¯
					infoEl.innerHTML = `
						<div class="font-info">
							<strong>${file.name}</strong><br>
							æ–‡ä»¶å¤§å°: ${(file.size / 1024).toFixed(1)} KB
						</div>
					`;
					infoEl.style.display = 'block';
				}
			}
			
			// ä»æ–‡ä»¶å¯¹è±¡è·å–å­—é‡ä¿¡æ¯
			async function getFontWeightsFromFile(file) {
				const weightCard = document.getElementById("weightCard");
				const weightOptions = document.getElementById("weightOptions");
				
				// æ˜¾ç¤ºåŠ è½½çŠ¶æ€
				weightCard.style.display = "block";
				weightOptions.innerHTML = "<div style='text-align: center; color: #666;'>æ­£åœ¨åˆ†æå­—ä½“å­—é‡...</div>";
				
				try {
					// å°†æ–‡ä»¶è½¬æ¢ä¸ºbase64
					const fileData = await fileToBase64(file);
					
					// è°ƒç”¨åç«¯APIè·å–å­—é‡ä¿¡æ¯
					if (window.pywebview && window.pywebview.api) {
						const weights = await window.pywebview.api.get_font_weights_from_data(fileData, file.name);
						
						if (weights && weights.length > 0) {
							availableWeights = weights;
							weightOptions.innerHTML = "";
							
							weights.forEach((weight) => {
								const inputId = `weight-${weight}`;
								const weightName = getWeightName(weight);
								weightOptions.innerHTML += `
									<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
									<label for="${inputId}">${weightName}</label>
								`;
							});
						} else {
							// éå¯å˜å­—ä½“ï¼šéšè—å­—é‡é€‰æ‹©åŒºåŸŸï¼Œç”±åç«¯æŒ‰é»˜è®¤å­—é‡å¤„ç†
							availableWeights = [];
							weightOptions.innerHTML = "";
							weightCard.style.display = "none";
						}
					} else {
						throw new Error('APIä¸å¯ç”¨');
					}
				} catch (error) {
					console.error('è·å–å­—é‡å¤±è´¥:', error);
					// å‡ºé”™æ—¶éšè—å­—é‡é€‰æ‹©åŒºåŸŸï¼Œç”±åç«¯æŒ‰é»˜è®¤å­—é‡å¤„ç†
					availableWeights = [];
					weightOptions.innerHTML = "";
					weightCard.style.display = "none";
				}
			}
			
			// å°†æ•°å­—å­—é‡è½¬æ¢ä¸ºå¯è¯»åç§°
			function getWeightName(weight) {
				const weightNames = {
					100: 'Thin (100)',
					200: 'Extra Light (200)',
					300: 'Light (300)',
					400: 'Regular (400)',
					500: 'Medium (500)',
					600: 'Semi Bold (600)',
					700: 'Bold (700)',
					800: 'Extra Bold (800)',
					900: 'Black (900)'
				};
				return weightNames[weight] || `${weight}`;
			}
			
			// åŠ è½½å­—ä½“ä¿¡æ¯ï¼ˆä¿ç•™åŸæœ‰å‡½æ•°ç”¨äºæ‹†åˆ†åŠŸèƒ½ï¼‰
			function loadFontInfo(filePath, infoElementId) {
				if (window.pywebview && window.pywebview.api) {
					const info = window.pywebview.api.get_font_info(filePath);
					if (info.success) {
						const infoEl = document.getElementById(infoElementId);
						infoEl.innerHTML = `
							<div class="font-info">
								<strong>${info.font_family}</strong> - ${info.font_style}<br>
								æ–‡ä»¶å¤§å°: ${info.file_size} | å­—ç¬¦æ•°: ${info.character_count.toLocaleString()}
								${info.is_variable ? '<br><span class="variable-font">ğŸ¨ å˜é‡å­—ä½“</span>' : ''}
							</div>
						`;
						infoEl.style.display = 'block';
					}
				}
			}
			
			// å–æ¶ˆå¤„ç†
			function cancelProcessing() {
				if (window.pywebview && window.pywebview.api) {
					const result = window.pywebview.api.cancel_processing();
					if (result.success) {
						updateResult(result.message, 'success');
						hideStatusBar();
					}
				}
			}
			
			// çŠ¶æ€æ ç®¡ç†
			function showStatusBar(message, showCancel = false) {
				const statusBar = document.getElementById('status-bar');
				const statusText = document.getElementById('status-text');
				const cancelBtn = document.getElementById('cancel-btn');
				
				statusText.textContent = message;
				cancelBtn.style.display = showCancel ? 'block' : 'none';
				statusBar.style.display = 'block';
			}
			
			function hideStatusBar() {
				document.getElementById('status-bar').style.display = 'none';
			}
			
			function updateProgress(percent) {
				const progressFill = document.getElementById('progress-fill');
				progressFill.style.width = percent + '%';
			}
			
			// æ›´æ–°è½¬æ¢æ–‡ä»¶æ˜¾ç¤º
			function updateConvertFileDisplay(filePath) {
				const dropZone = document.getElementById('mainDropZone');
				const fileName = filePath.split('/').pop() || filePath.split('\\').pop();
				dropZone.innerHTML = `
					<div class="drop-zone-content file-selected">
						<div class="drop-icon">âœ…</div>
						<h3>å·²é€‰æ‹©æ–‡ä»¶</h3>
						<p>${fileName}</p>
					</div>
				`;
				
				// æ›´æ–°å³ä¾§çš„é€‰æ‹©æŒ‰é’®æ–‡æœ¬
				const selectBtn = document.getElementById('selectFileBtn');
				if (selectBtn) {
					selectBtn.textContent = 'é‡æ–°é€‰æ‹©';
				}
				
				// é‡æ–°ç»‘å®šæ‹–æ‹½äº‹ä»¶
				dropZone.setAttribute('ondrop', 'handleDrop(event, "convert-input")');
				dropZone.setAttribute('ondragover', 'handleDragOver(event)');
				dropZone.setAttribute('ondragleave', 'handleDragLeave(event)');
			}
			
			// palåŒ…é…ç½®
			const PAL_CONFIG = {
				clientId: '1065', // éœ€è¦æ›¿æ¢ä¸ºå®é™…çš„clientId
				path:'activity',
				operate_id: 'web_fontmin_utils',
				retryCount: 1,
				withHash: false,
				hashAlgorithm: 'MD5',
			}

			// ç»Ÿä¸€å­—ç¬¦é›†å®šä¹‰
			const quickCharSets = {
				"å¸¸ç”¨(æ¨è)": "å¸¸ç”¨å­—ç¬¦é›†",
				å¸¸ç”¨ç¬¦å·: "å¸¸ç”¨ç¬¦å·",
				å…¨éƒ¨æ•°å­—: "0123456789",
				å¤§å°å†™è‹±æ–‡: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
				ç®€ä½“ä¸­æ–‡: "ç®€ä½“ä¸­æ–‡é›†",
				ç¹ä½“ä¸­æ–‡: "ç¹ä½“ä¸­æ–‡é›†",
				å…¨éƒ¨æ—¥æ–‡: "æ—¥æ–‡å­—ç¬¦é›†",
				å…¨éƒ¨éŸ©æ–‡: "éŸ©æ–‡å­—ç¬¦é›†"
			}
			const allUnicodeRanges = {
				å¸¸ç”¨å­—ç¬¦é›†: (() => {
					const chars = new Set()
					for (let i = 0x0021; i <= 0x007f; i++) chars.add(String.fromCharCode(i))
					for (let i = 0x4e00; i <= 0x9fff; i++) chars.add(String.fromCharCode(i))
					for (let i = 0x3000; i <= 0x303f; i++) chars.add(String.fromCharCode(i))
					for (let i = 0xff00; i <= 0xffef; i++) chars.add(String.fromCharCode(i))
					return Array.from(chars).join("")
				})(),
				å¸¸ç”¨ç¬¦å·: (() => {
					const addRange = (set, start, end) => { for (let i = start; i <= end; i++) set.add(String.fromCharCode(i)) }
					const s = new Set()
					// ASCII punctuation
					addRange(s, 0x0020, 0x002f); addRange(s, 0x003a, 0x0040); addRange(s, 0x005b, 0x0060); addRange(s, 0x007b, 0x007e)
					// General Punctuation
					addRange(s, 0x2000, 0x206f)
					// Currency Symbols
					addRange(s, 0x20a0, 0x20cf)
					// CJK Symbols and Punctuation
					addRange(s, 0x3000, 0x303f)
					// Halfwidth and Fullwidth Forms (éƒ¨åˆ†å¸¸ç”¨æ ‡ç‚¹)
					addRange(s, 0xff00, 0xff65); addRange(s, 0xffe0, 0xffee)
					return Array.from(s).join("")
				})(),
				ç®€ä½“ä¸­æ–‡é›†: Array.from({ length: 0x9fff - 0x4e00 + 1 }, (_, i) => String.fromCharCode(0x4e00 + i)).join(""),
				ç¹ä½“ä¸­æ–‡é›†:
					Array.from({ length: 0x4dbf - 0x3400 + 1 }, (_, i) => String.fromCharCode(0x3400 + i)).join("") +
					Array.from({ length: 0x9fff - 0x4e00 + 1 }, (_, i) => String.fromCharCode(0x4e00 + i)).join(""),
				æ—¥æ–‡å­—ç¬¦é›†:
					Array.from({ length: 0x309f - 0x3040 + 1 }, (_, i) => String.fromCharCode(0x3040 + i)).join("") +
					Array.from({ length: 0x30ff - 0x30a0 + 1 }, (_, i) => String.fromCharCode(0x30a0 + i)).join("") +
					Array.from({ length: 0x31ff - 0x31f0 + 1 }, (_, i) => String.fromCharCode(0x31f0 + i)).join(""),
				éŸ©æ–‡å­—ç¬¦é›†: Array.from({ length: 0xd7a3 - 0xac00 + 1 }, (_, i) => String.fromCharCode(0xac00 + i)).join("")
			}

			function renderQuickCharCheckboxes() {
				const container = document.getElementById("quickCharsContainer")
				container.innerHTML = ""
				Object.entries(quickCharSets).forEach(([label, value], index) => {
					const isDefault = false // é»˜è®¤ä¸å‹¾é€‰ä»»ä½•å­—ç¬¦é›†ï¼Œé¿å…è¯¯åŒ…å«å…¨éƒ¨å­—ç¬¦
					const inputId = `quick-char-${index}`
					container.innerHTML += `
                    <label for="${inputId}">
                        <input type="checkbox" id="${inputId}" data-chars="${value}" ${isDefault ? "checked" : ""}>
                        <span class="checkmark"></span>
                        ${label}
                    </label>
                `
				})
			}

			renderQuickCharCheckboxes()

			function updateResult(message, type) {
				const resultDiv = document.getElementById("result")
				resultDiv.innerText = message
				resultDiv.className = `result ${type || "info"}`
			}


			async function getFontWeights(filePath) {
				try {
					// æ£€æŸ¥APIæ˜¯å¦å¯ç”¨
					if (!window.pywebview || !window.pywebview.api) {
						console.log('pywebview API ä¸å¯ç”¨ï¼Œè·³è¿‡å­—é‡è·å–')
						return
					}
					
					const weights = await window.pywebview.api.get_font_weights(filePath)
					availableWeights = weights
					
					const weightCard = document.getElementById("weightCard")
					const weightOptions = document.getElementById("weightOptions")
					weightOptions.innerHTML = ""
					
					if (weights && weights.length > 0) {
						weightCard.style.display = "block"
						weights.forEach((weight) => {
							const inputId = `weight-${weight}`
							weightOptions.innerHTML += `
								<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
								<label for="${inputId}">${weight}</label>
							`
						})
					} else {
						weightCard.style.display = "none"
					}
				} catch (e) {
					console.error('è·å–å­—é‡å¤±è´¥:', e)
					// å¦‚æœè·å–å­—é‡å¤±è´¥ï¼Œéšè—å­—é‡é€‰æ‹©åŒºåŸŸ
					document.getElementById("weightCard").style.display = "none"
				}
			}

			async function selectInputFile() {
				console.log('selectInputFile è¢«è°ƒç”¨');
				try {
					updateResult("æ­£åœ¨å‘¼å«æ–‡ä»¶é€‰æ‹©çª—å£ï¼Œè¯·ç¨å€™...", "info")
					
					// æ£€æŸ¥APIæ˜¯å¦å¯ç”¨
					if (!window.pywebview || !window.pywebview.api) {
						console.error('webview API ä¸å¯ç”¨');
						updateResult("âŒ APIä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥åº”ç”¨çŠ¶æ€", "error");
						return;
					}
					
					console.log('è°ƒç”¨ select_input_file API');
					inputFile = await window.pywebview.api.select_input_file()
					console.log('API è¿”å›ç»“æœ:', inputFile);
					
					const convertBtn = document.getElementById("convertBtn")
					
					if (inputFile) {
						updateConvertFileDisplay(inputFile)
						convertBtn.disabled = false
						outputFolder = null
						updateResult("", "success")
						
						const weights = await window.pywebview.api.get_font_weights(inputFile)
						availableWeights = weights
						
						const weightCard = document.getElementById("weightCard")
						const weightOptions = document.getElementById("weightOptions")
						weightOptions.innerHTML = ""
						
						if (weights && weights.length > 0) {
							weightCard.style.display = "block"
							weights.forEach((weight) => {
								const inputId = `weight-${weight}`
								weightOptions.innerHTML += `
									<input type="checkbox" id="${inputId}" name="weight" value="${weight}">
									<label for="${inputId}">${weight}</label>
								`
							})
						} else {
							weightCard.style.display = "none"
						}
					} else {
						// æ— è¿”å›æ—¶ï¼Œä¸æç¤º"å–æ¶ˆ"ï¼Œä»…é™é»˜æ¢å¤
						updateResult("", "info")
						const convertBtn = document.getElementById("convertBtn")
						convertBtn.disabled = true
						document.getElementById("weightCard").style.display = "none"
					}
				} catch (e) {
					console.error('é€‰æ‹©è¾“å…¥æ–‡ä»¶å¤±è´¥:', e)
					updateResult("é€‰æ‹©æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚", "error")
				}
			}



			async function startConversion() {
				if (!selectedFileData) {
					updateResult("âŒ è¯·å…ˆé€‰æ‹©å­—ä½“æ–‡ä»¶å“¦ï¼", "error")
					return
				}

				const selectedFormats = Array.from(document.querySelectorAll(".format-options input:checked")).map(
					(el) => el.value
				)

				console.log("é€‰ä¸­çš„æ ¼å¼:", selectedFormats)
				console.log("æ‰€æœ‰æ ¼å¼é€‰é¡¹:", document.querySelectorAll(".format-options input"))

				if (selectedFormats.length === 0) {
					updateResult("âŒ è¯·è‡³å°‘é€‰æ‹©ä¸€ç§è¾“å‡ºæ ¼å¼ï¼", "error")
					return
				}

				const subsetChars = document.getElementById("subsetChars").value
				const selectedQuickChars = Array.from(document.querySelectorAll("#quickCharsContainer input:checked")).map(
					(el) => el.getAttribute("data-chars")
				)

				const allChars = Array.from(
					new Set(
						(
							subsetChars +
							selectedQuickChars
								.map((chars) => {
									return allUnicodeRanges[chars] || chars
								})
								.join("")
						).split("")
					)
				).join("")

				const selectedWeights = Array.from(document.querySelectorAll("#weightOptions input:checked")).map(
					(el) => el.value
				)

				const convertBtn = document.getElementById("convertBtn")
				convertBtn.disabled = true

				updateResult("ğŸš€ è½¬æ¢ä»»åŠ¡å·²æäº¤ï¼Œè¯·è€å¿ƒç­‰å¾…...", "info")

				// å°†æ–‡ä»¶è½¬æ¢ä¸ºbase64å‘é€ç»™åç«¯
				const fileData = await fileToBase64(selectedFileData);
				
				const result = await window.pywebview.api.start_conversion_with_file(
					fileData,
					selectedFileData.name,
					allChars,
					selectedWeights,
					outputFolder,
					selectedFormats
				)

				convertBtn.disabled = false

				if (result.success) {
					let message = `ğŸ‰ è½¬æ¢å®Œæˆï¼æ€»è€—æ—¶ï¼š${result.total_time_seconds.toFixed(2)} ç§’\n`
					if (result.paths && result.paths.length > 0) {
						message += "\nè½¬æ¢åçš„æ–‡ä»¶ä½äºï¼š\n" + result.paths.join("\n")
					}
					updateResult(message, "success")
				} else {
					updateResult(result.message, "error")
				}
			}
			
			// æ·»åŠ æ‹†åˆ†æ–‡ä»¶æ•°æ®å˜é‡
			let splitFileData = null;
			
			function selectSplitInputFile() {
				pywebview.api.select_input_file().then(result => {
					if (result) {
						splitInputFile = result;
						document.getElementById('split-input-file').value = result;
					}
				});
			}

			function selectSplitOutputFolder() {
				pywebview.api.select_output_folder().then(result => {
					if (result) {
						window.splitOutputFolder = result;
						document.getElementById('split-output-folder').value = result;
					}
				});
			}


			function showSplitStatus(type, message) {
				// ä½¿ç”¨ä»»åŠ¡çŠ¶æ€æ˜¾ç¤ºæ¶ˆæ¯
				showTaskStatus(message, '', false);
			}

			function showSplitProgress(percent) {
				// ä½¿ç”¨ä»»åŠ¡è¿›åº¦æ˜¾ç¤º
				updateTaskProgress(percent);
			}

			function hideSplitProgress() {
				// ä¸éœ€è¦éšè—ï¼Œä»»åŠ¡çŠ¶æ€ä¼šç»Ÿä¸€ç®¡ç†
			}

			// ä»»åŠ¡è¿›åº¦ç®¡ç†å‡½æ•°
			function showTaskStatus(title, detail = '', showProgress = false) {
				const taskStatusEl = document.getElementById('task-status');
				const titleEl = document.getElementById('task-status-title');
				const detailEl = document.getElementById('task-status-detail');
				const progressEl = document.getElementById('task-progress');
				
				titleEl.textContent = title;
				
				// æ”¯æŒHTMLå†…å®¹ï¼Œä¸”å…¼å®¹éå­—ç¬¦ä¸²
				if (typeof detail === 'string' && detail.indexOf('<') >= 0) {
					detailEl.innerHTML = detail;
				} else {
					detailEl.textContent = (detail || '').toString();
				}
				
				taskStatusEl.style.display = 'block';
				
				if (showProgress) {
					progressEl.style.display = 'block';
				} else {
					progressEl.style.display = 'none';
				}
			}

			function hideTaskStatus() {
				document.getElementById('task-status').style.display = 'none';
			}

			function updateTaskProgress(percent) {
				const progressBar = document.getElementById('task-progress-bar');
				progressBar.style.width = percent + '%';
			}



			// ä½¿ç”¨momoåŒ…çš„ä¸Šä¼ å‡½æ•°
			async function uploadToCDN(filePath, filename, language) {
				try {
					console.log('ğŸ” uploadToCDN å¼€å§‹æ‰§è¡Œ:');
					console.log('  - filePath:', filePath);
					console.log('  - filename:', filename);
					console.log('  - language:', language);
					
					// æ£€æŸ¥ fileUpload å‡½æ•°æ˜¯å¦å­˜åœ¨
					if (typeof window.fileUpload !== 'function') {
						throw new Error('fileUpload å‡½æ•°ä¸å­˜åœ¨');
					}
					console.log('âœ… fileUpload å‡½æ•°å­˜åœ¨');
					
					// åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„Fileå¯¹è±¡ï¼Œä¸éœ€è¦å®é™…è¯»å–æ–‡ä»¶
					const mockFile = new File([''], filename, { type: 'application/octet-stream' });
					console.log('âœ… æ¨¡æ‹ŸFileå¯¹è±¡åˆ›å»ºæˆåŠŸ:', mockFile.name);
					
					// ä½¿ç”¨æ¨¡æ‹Ÿçš„fileUploadå‡½æ•°
					console.log('ğŸ” å¼€å§‹æ¨¡æ‹Ÿä¸Šä¼ ...');
					const result = await window.fileUpload({
						clientId: '1065',
						file: [mockFile], // æ–‡ä»¶æ•°ç»„
						path: 'activity',
						operate_id: 'web_fontmin_utils',
						retryCount: 1,
						withHash: false,
						hashAlgorithm: 'MD5',
						onProgress: (percent) => {
							console.log(`ä¸Šä¼ è¿›åº¦: ${Math.round(percent * 100)}%`);
						},
						onSingleFinish: (res, index) => {
							console.log('å•ä¸ªæ–‡ä»¶ä¸Šä¼ å®Œæˆ:', res);
						}
					});
					
					console.log('ğŸ” ä¸Šä¼ ç»“æœ:', result);
					
					// è¿”å›ç¬¬ä¸€ä¸ªæ–‡ä»¶çš„URL
					if (result && result.files && result.files.length > 0 && result.files[0].success) {
						const url = result.files[0].resourceUrl;
						console.log('âœ… ä¸Šä¼ æˆåŠŸï¼Œè¿”å›URL:', url);
						return url;
					} else {
						throw new Error('ä¸Šä¼ å¤±è´¥ï¼Œç»“æœ:', result);
					}
					
				} catch (error) {
					console.error('âŒ uploadToCDN å¤±è´¥:', error);
					throw error;
				}
			}

			// åˆå§‹åŒ–
				document.addEventListener('DOMContentLoaded', function() {
				selectLanguage('zh'); // é»˜è®¤é€‰æ‹©ç®€ä½“ä¸­æ–‡
			});
		</script>
	</body>
</html>

